var no=Object.defineProperty;var ye=(e,t)=>{for(var o in t)no(e,o,{get:t[o],enumerable:!0})};var it={};ye(it,{$componentCount:()=>de,$componentMap:()=>x,$schema:()=>st});var x=Symbol("componentMap"),de=Symbol("componentCount"),st=Symbol("schema");var at={};ye(at,{$dirtyQueries:()=>U,$enterQuery:()=>io,$exitQuery:()=>ao,$modifier:()=>N,$notQueries:()=>G,$queries:()=>M,$queriesHashMap:()=>V,$queryComponents:()=>be,$queryDataMap:()=>S,$querySparseSet:()=>so,$queueRegisters:()=>ne});var N=Symbol("$modifier"),M=Symbol("queries"),G=Symbol("notQueries"),V=Symbol("queriesHashMap"),so=Symbol("querySparseSet"),ne=Symbol("queueRegisters"),S=Symbol("queryDataMap"),U=Symbol("$dirtyQueries"),be=Symbol("queryComponents"),io=Symbol("enterQuery"),ao=Symbol("exitQuery");var ut={};ye(ut,{$entityArray:()=>A,$entityComponents:()=>W,$entityIndices:()=>uo,$entityMasks:()=>$,$entitySparseSet:()=>E,$removedEntities:()=>co});var $=Symbol("entityMasks"),W=Symbol("entityComponents"),E=Symbol("entitySparseSet"),A=Symbol("entityArray"),uo=Symbol("entityIndices"),co=Symbol("removedEntities");var ct={};ye(ct,{$prefabComponents:()=>qe,$worldToPrefab:()=>B});var qe=Symbol("prefabComponents"),B=Symbol("worldToPrefab");var Q=()=>{let e=[],t=[],o=i=>e[t[i]]===i;return{add:i=>{o(i)||(t[i]=e.push(i)-1)},remove:i=>{if(!o(i))return;let a=t[i],f=e.pop();f!==i&&(e[a]=f,t[f]=a)},has:o,sparse:t,dense:e,reset:()=>{e.length=0,t.length=0},sort:()=>{e.sort((i,a)=>i-a);for(let i=0;i<e.length;i++)t[e[i]]=i}}};import He from"@bitecs/utils/Uint32SparseSet";import{isSabSupported as vt}from"@bitecs/utils";var he={i8:"i8",ui8:"ui8",ui8c:"ui8c",i16:"i16",ui16:"ui16",i32:"i32",ui32:"ui32",f32:"f32",f64:"f64",eid:"eid"},ft={i8:"Int8",ui8:"Uint8",ui8c:"Uint8Clamped",i16:"Int16",ui16:"Uint16",i32:"Int32",ui32:"Uint32",eid:"Uint32",f32:"Float32",f64:"Float64"},J={i8:Int8Array,ui8:Uint8Array,ui8c:Uint8ClampedArray,i16:Int16Array,ui16:Uint16Array,i32:Int32Array,ui32:Uint32Array,f32:Float32Array,f64:Float64Array,eid:Uint32Array},pt={uint8:2**8,uint16:2**16,uint32:2**32},Se=Object.freeze([]);var bt={};ye(bt,{$indexBytes:()=>ae,$indexType:()=>ie,$isEidType:()=>xe,$parentArray:()=>Te,$queryShadow:()=>mo,$serializeShadow:()=>lo,$storeArrayElementCounts:()=>Ye,$storeBase:()=>X,$storeFlattened:()=>O,$storeMaps:()=>lt,$storeRef:()=>mt,$storeSize:()=>Re,$storeSubarrays:()=>Ee,$storeType:()=>yt,$subarray:()=>dt,$subarrayCursors:()=>Le,$subarrayFrom:()=>fo,$subarrayTo:()=>po,$tagStore:()=>se});var mt=Symbol("storeRef"),Re=Symbol("storeSize"),lt=Symbol("storeMaps"),O=Symbol("storeFlattened"),X=Symbol("storeBase"),yt=Symbol("storeType"),Ye=Symbol("storeArrayElementCounts"),Ee=Symbol("storeSubarrays"),Le=Symbol("subarrayCursors"),dt=Symbol("subarray"),fo=Symbol("subarrayFrom"),po=Symbol("subarrayTo"),Te=Symbol("parentArray"),se=Symbol("tagStore"),mo=Symbol("queryShadow"),lo=Symbol("serializeShadow"),ie=Symbol("indexType"),ae=Symbol("indexBytes"),xe=Symbol("isEidType");var yo=e=>t=>Math.ceil(t/e)*e,bo=yo(4),Z={};var Fe=(e,t)=>{if(ArrayBuffer.isView(e))e[t]=e.slice(0);else{let o=e[Te].slice(0);e[t]=e.map((r,n)=>{let{length:s}=e[n],u=s*n,i=u+s;return o.subarray(u,i)})}};var ht=(e,t)=>{e[O]&&e[O].forEach(o=>{ArrayBuffer.isView(o)?o[t]=0:o[t].fill(0)})},ho=(e,t)=>{let o=t*J[e].BYTES_PER_ELEMENT,r=vt()?new SharedArrayBuffer(o):new ArrayBuffer(o),n=new J[e](r);return n[xe]=e===he.eid,n},xo=e=>e[Te],go=(e,t,o)=>{let r=e[Re],n=Array(r).fill(0);n[yt]=t,n[xe]=t===he.eid;let s=e[Le],u=o<=pt.uint8?he.ui8:o<=pt.uint16?he.ui16:he.ui32;if(!o)throw new Error("bitECS - Must define component array length");if(!J[t])throw new Error(`bitECS - Invalid component array property type ${t}`);if(!e[Ee][t]){let f=e[Ye][t],m=bo(f*r)*J[t].BYTES_PER_ELEMENT,p=vt()?new SharedArrayBuffer(m):new ArrayBuffer(m),R=new J[t](p);R[ie]=ft[u],R[ae]=J[u].BYTES_PER_ELEMENT,e[Ee][t]=R}let i=s[t],a=i+r*o;s[t]=a,n[Te]=e[Ee][t].subarray(i,a);for(let f=0;f<r;f++){let m=o*f,p=m+o;n[f]=n[Te].subarray(m,p),n[f][ie]=ft[u],n[f][ae]=J[u].BYTES_PER_ELEMENT,n[f][dt]=!0}return n},Pt=e=>Array.isArray(e)&&typeof e[0]=="string"&&typeof e[1]=="number",Bt=(e,t)=>{let o=Symbol("store");if(!e||!Object.keys(e).length)return Z[o]={[Re]:t,[se]:!0,[X]:()=>Z[o]},Z[o];e=JSON.parse(JSON.stringify(e));let r={},n=u=>{let i=Object.keys(u);for(let a of i)Pt(u[a])?(r[u[a][0]]||(r[u[a][0]]=0),r[u[a][0]]+=u[a][1]):u[a]instanceof Object&&n(u[a])};n(e);let s={[Re]:t,[lt]:{},[Ee]:{},[mt]:o,[Le]:Object.keys(J).reduce((u,i)=>({...u,[i]:0}),{}),[O]:[],[Ye]:r};if(e instanceof Object&&Object.keys(e).length){let u=(i,a)=>{if(typeof i[a]=="string")i[a]=ho(i[a],t),i[a][X]=()=>Z[o],s[O].push(i[a]);else if(Pt(i[a])){let[f,m]=i[a];i[a]=go(s,f,m),i[a][X]=()=>Z[o],s[O].push(i[a])}else i[a]instanceof Object&&(i[a]=Object.keys(i[a]).reduce(u,i[a]));return i};return Z[o]=Object.assign(Object.keys(e).reduce(u,e),s),Z[o][X]=()=>Z[o],Z[o]}};var Me=(e,t)=>t.sort((o,r)=>{typeof o=="function"&&o[N]&&(o=o()[0]),typeof r=="function"&&r[N]&&(r=r()[0]),e[x].has(o)||q(e,o),e[x].has(r)||q(e,r);let n=e[x].get(o),s=e[x].get(r);return n.id>s.id?1:-1}).reduce((o,r)=>{let n;typeof r=="function"&&r[N]&&(n=r()[1],r=r()[0]),e[x].has(r)||q(e,r);let s=e[x].get(r);return n?o+=`-${n}(${s.id})`:o+=`-${s.id}`,o},"");var xt={};ye(xt,{$archetypes:()=>Ae,$bitflag:()=>Y,$bufferQueries:()=>k,$localEntities:()=>K,$localEntityLookup:()=>L,$manualEntityRecycling:()=>z,$size:()=>P});var P=Symbol("size"),Y=Symbol("bitflag"),Ae=Symbol("archetypes"),K=Symbol("localEntities"),L=Symbol("localEntityLookup"),z=Symbol("manualEntityRecycling"),k=Symbol("bufferQueries");var Pe=[];function zt(e,t){let o=()=>[e,t];return o[N]=!0,o}var So=e=>zt(e,"not");var Eo=e=>zt(e,"changed");function To(...e){return function(){return e}}function $o(...e){return function(){return e}}function Oo(...e){return function(){return e}}var $e=(e,t)=>{if(e[S].has(t))return;let o=[],r=[],n=[];t[be].forEach(c=>{if(typeof c=="function"&&c[N]){let[h,I]=c();e[x].has(h)||q(e,h),I==="not"&&r.push(h),I==="changed"&&(n.push(h),o.push(h))}else e[x].has(c)||q(e,c),o.push(c)});let s=c=>e[x].get(c),u=o.concat(r).map(s),i;if(e[k]){let c=e[P]===-1?1e5:e[P]*2;i=He.create(1024,c>1024?c:1024)}else i=Q();let a=[],f=[],m=Q(),p=[Q()],R=[Q()],_=u.map(c=>c.generationId).reduce((c,h)=>(c.includes(h)||c.push(h),c),[]),d=(c,h)=>(c[h.generationId]||(c[h.generationId]=0),c[h.generationId]|=h.bitflag,c),g=o.map(s).reduce(d,{}),me=r.map(s).reduce(d,{}),y=u.reduce(d,{}),le=o.filter(c=>!c[se]).map(c=>Object.getOwnPropertySymbols(c).includes(O)?c[O]:[c]).reduce((c,h)=>c.concat(h),[]),T=Object.assign(i,{archetypes:a,changed:f,components:o,notComponents:r,changedComponents:n,allComponents:u,masks:g,notMasks:me,hasMasks:y,generations:_,flatProps:le,toRemove:m,enterQueues:p,exitQueues:R,shadows:[],query:t});e[S].set(t,T),e[M].add(T);let l=Me(e,t[be]);e[V].set(l,T),u.forEach(c=>{c.queries.add(T)}),r.length&&e[G].add(T),t[ne].forEach(c=>c(e));for(let c=0;c<jt();c++){if(!e[E].has(c)||F(e,ge,c))continue;Oe(e,T,c)&&Ce(T,c)}},Co=(e,t)=>{let o=Symbol(),r=e.flatProps[t];return Fe(r,o),e.shadows[t]=r[o],r[o]},Wo=(e,t)=>{t&&(e.changed=[]);let{flatProps:o,shadows:r}=e;for(let n=0;n<e.dense.length;n++){let s=e.dense[n],u=!1;for(let i=0;i<o.length;i++){let a=o[i],f=r[i]||Co(e,i);if(ArrayBuffer.isView(a[s])){for(let m=0;m<a[s].length;m++)if(a[s][m]!==f[s][m]){u=!0;break}f[s].set(a[s])}else a[s]!==f[s]&&(u=!0,f[s]=a[s])}u&&e.changed.push(s)}return e.changed},Qo=(e,t)=>e.concat(t),gt=e=>t=>t.filter(o=>o.name===e().constructor.name).reduce(Qo),Or=gt(To),Cr=gt($o),Wr=gt(Oo),ve=e=>{if(e===void 0){let o=function(r){return r[k]?new Uint32Array(r[A]):Array.from(r[A])};return o[be]=e,o[ne]=[],o}let t=function(o,r=!0){let n=o[S].get(t);return kt(o),n.changedComponents.length?Wo(n,r):n.changedComponents.length?n.changed.dense:o[k]?n.dense:Array.from(n.dense)};return t[be]=e,t[ne]=[],Pe.push(t),j.forEach(o=>$e(o,t)),t};function Be(e,t){if(Array.isArray(t)){let o=t,r=Me(e,o),n=e[V].get(r);return n?n.query(e):ve(o)(e)}else{let o=t;return e[k]?new Uint32Array(o(e)):Array.from(o(e))}}var Oe=(e,t,o)=>{let{masks:r,notMasks:n,generations:s}=t;for(let u=0;u<s.length;u++){let i=s[u],a=r[i],f=n[i],m=e[$][i][o];if(f&&m&f||a&&(m&a)!==a)return!1}return!0};var Ce=(e,t)=>{e.toRemove.remove(t);for(let o=0;o<e.enterQueues.length;o++)e.enterQueues[o].add(t);for(let o=0;o<e.exitQueues.length;o++)e.exitQueues[o].remove(t);e.dense instanceof Uint32Array?He.add(e,t):e.add(t)},Do=e=>{for(let t=e.toRemove.dense.length-1;t>=0;t--){let o=e.toRemove.dense[t];e.toRemove.remove(o),e.dense instanceof Uint32Array?He.remove(e,o):e.remove(o)}},kt=e=>{e[U].size&&(e[U].forEach(Do),e[U].clear())},ze=(e,t,o)=>{if(!(!(e[k]?He.has(t,o):t.has(o))||t.toRemove.has(o))){t.toRemove.add(o),e[U].add(t);for(let n=0;n<t.exitQueues.length;n++)t.exitQueues[n].add(o);for(let n=0;n<t.enterQueues.length;n++)t.enterQueues[n].remove(o)}},Ro=(e,t)=>{let o=e[S].get(t);o.changed=[]},Mo=(e,t)=>{let o=e[S].get(t);e[M].delete(o),e[S].delete(t);let r=Me(e,t[be]);e[V].delete(r)},Ao=e=>t=>{t[S].has(e)||$e(t,e);let o=t[S].get(e);if(o.enterQueues[0].dense.length===0)return Se;{let r=o.enterQueues[0].dense.slice();return o.enterQueues[0].reset(),r}},Po=e=>t=>{t[S].has(e)||$e(t,e);let o=t[S].get(e);if(o.exitQueues[0].dense.length===0)return Se;{let r=o.exitQueues[0].dense.slice();return o.exitQueues[0].reset(),r}};var w=(e,t,o)=>Object.defineProperty(e,t,{value:o,enumerable:!1,writable:!0,configurable:!0}),Ge=(e,t)=>{let o={enumerable:!1,writable:!0,configurable:!0};Object.defineProperties(e,Reflect.ownKeys(t).reduce((r,n)=>Object.assign(r,{[n]:{value:t[n],...o}}),{}))};var St={};ye(St,{$autoRemoveSubject:()=>je,$exclusiveRelation:()=>ke,$initStore:()=>Je,$isPairComponent:()=>ue,$onTargetRemoved:()=>We,$pairTarget:()=>C,$pairsMap:()=>Ve,$relation:()=>ee,$relationTargetEntities:()=>te});var Ve=Symbol("pairsMap"),ue=Symbol("isPairComponent"),ee=Symbol("relation"),C=Symbol("pairTarget"),We=Symbol("onTargetRemoved"),ke=Symbol("exclusiveRelation"),je=Symbol("autoRemoveSubject"),te=Symbol("relationTargetEntities"),Je=Symbol("initStore");function _t(e,t,o,r){if(!o.has(r)){let n=t();w(n,ue,!0),w(n,ee,e),w(n,C,r),o.set(r,n)}return o.get(r)}var It=e=>{let t=e?.initStore||(()=>({})),o=new Map,r=function(n){if(n===void 0)throw Error("Relation target is undefined");return n==="*"&&(n=D),_t(r,t,o,n)};return w(r,Ve,o),w(r,Je,t),w(r,ke,e&&e.exclusive),w(r,je,e&&e.autoRemoveSubject),w(r,We,e?e.onTargetRemoved:void 0),r},ce=(e,t)=>{if(e===void 0)throw Error("Relation is undefined");if(t===void 0)throw Error("Relation target is undefined");t==="*"&&(t=D);let o=e[Ve],r=e[Je];return _t(e,r,o,t)},D=It(),_e=It(),Ie=(e,t,o)=>{let r=Ne(e,o),n=[];for(let s of r)if(s[ee]===t&&s[C]!==D)if(typeof s[C]=="object"&&s[C][B]){let u=s[C][B].get(e);u==null&&(u=Et(e,s[C])),n.push(u)}else n.push(s[C]);return n};var Tt=(e={},t)=>{let o=Bt(e,t||Xe());return e&&Object.keys(e).length&&(o[st]=e),o},q=(e,t)=>{if(!t)throw new Error("bitECS - Cannot register null or undefined component");let o=new Set,r=new Set,n=new Set;e[M].forEach(u=>{u.allComponents.includes(t)&&o.add(u)});let s={id:e[de]++,generationId:e[$].length-1,bitflag:e[Y],ref:t,queries:o,notQueries:r,changedQueries:n};e[x].set(t,s),Ut(e)},vo=(e,t)=>{t.forEach(o=>q(e,o))},F=(e,t,o)=>{let r=e[x].get(t);if(!r)return!1;let{generationId:n,bitflag:s}=r;return(e[$][n][o]&s)===s},Nt=(e,t,o)=>{o instanceof Object&&(o=o[B].get(e)),H(e,_e(o),t);let r=Ne(e,o);for(let s of r){if(s===ge)continue;H(e,s,t);let u=Object.keys(s);for(let i of u)s[i][t]=s[i][o]}let n=Ie(e,_e,o);for(let s of n)Nt(e,t,s)},H=(e,t,o,r=!1)=>{if(!Ot(e,o))throw new Error("bitECS - entity does not exist in the world.");if(e[x].has(t)||q(e,t),F(e,t,o))return;let n=e[x].get(t),{generationId:s,bitflag:u,queries:i}=n;if(e[$][s][o]|=u,F(e,ge,o)||i.forEach(a=>{a.toRemove.remove(o),Oe(e,a,o)?Ce(a,o):ze(e,a,o)}),e[W].get(o).add(t),r&&ht(t,o),t[ue]){let a=t[ee];H(e,ce(a,D),o);let f=t[C];if(H(e,ce(D,f),o),a[ke]===!0&&f!==D){let m=Ie(e,a,o)[0];m&&m!==f&&fe(e,a(m),o)}if(e[te].add(f),a===_e){let m=Ie(e,_e,o);for(let p of m)Nt(e,o,p)}}},$t=(e,t,o,r=!1)=>{t.forEach(n=>H(e,n,o,r))},fe=(e,t,o,r=!0)=>{if(!Ot(e,o))throw new Error("bitECS - entity does not exist in the world.");if(!F(e,t,o))return;let n=e[x].get(t),{generationId:s,bitflag:u,queries:i}=n;if(e[$][s][o]&=~u,i.forEach(a=>{a.toRemove.remove(o),Oe(e,a,o)?Ce(a,o):ze(e,a,o)}),e[W].get(o).delete(t),r&&ht(t,o),t[ue]){Be(e,[D(o)]).length===0&&e[te].remove(o);let a=t[C];fe(e,ce(D,a),o);let f=t[ee];Ie(e,f,o).length===0&&fe(e,ce(f,D),o)}},Bo=(e,t,o,r=!0)=>{t.forEach(n=>fe(e,n,o,r))};var Ke=1e5,Wt=0,we=Ke,Xe=()=>we,De=[],Qe=[],Ze=[],zo=()=>{if(Qe.length===0)for(;De.length>0;)Qe.push(De.pop());if(Qe.length===0)throw new Error("Queue is empty");return Qe.pop()},qt=()=>De.length+Qe.length,Yt=.01,Qt=Yt,Lt=()=>{we=Ke,Wt=0,Qt=Yt,De.length=0,Qe.length=0,Ze.length=0,Pe.length=0,j.length=0},ko=()=>Ke,jo=e=>{Ke=e,Lt(),we=e},_o=e=>{Qt=e},jt=()=>Wt;var Dt=new Map,Io=e=>{if(!e[z])throw new Error("bitECS - cannot flush removed entities, enable feature with the enableManualEntityRecycling function");De.push(...Ze),Ze.length=0},ge=Tt(),pe=e=>{let t;if(e[z]&&qt()>0||!e[z]&&qt()>Math.round(we*Qt)?t=zo():t=Wt++,e[P]!==-1&&e[E].dense.length>=e[P])throw new Error("bitECS - max entities reached");return e[E].add(t),Dt.set(t,e),e[G].forEach(o=>{Oe(e,o,t)&&Ce(o,t)}),e[W].set(t,new Set),t},et=(e,t)=>{if(e[E].has(t)){if(e[te].has(t)){for(let o of Be(e,[ce(D,t)]))if(Ct(e,o)){fe(e,ce(D,t),o);for(let r of e[W].get(o)){if(!r[ue]||!Ct(e,o))continue;let n=r[ee];r[C]===t&&(fe(e,r,o),n[je]&&et(e,o),n[We]&&n[We](e,o,t))}}}for(let o of e[M])ze(e,o,t);e[z]?Ze.push(t):De.push(t),e[E].remove(t),e[W].delete(t),e[K].delete(e[L].get(t)),e[L].delete(t);for(let o=0;o<e[$].length;o++)e[$][o][t]=0}},Ne=(e,t)=>{if(t===void 0)throw new Error("bitECS - entity is undefined.");if(!e[E].has(t))throw new Error("bitECS - entity does not exist in the world.");return Array.from(e[W].get(t))},Ct=(e,t)=>e[E].has(t);var j=[];function Ft(...e){let t=typeof e[0]=="object"?e[0]:{},o=typeof e[0]=="number"?e[0]:typeof e[1]=="number"?e[1]:-1,r=Q();return Ge(t,{[P]:o,[$]:[o===-1?new Array:new Array(o)],[W]:new Map,[Ae]:[],[E]:r,[A]:r.dense,[Y]:1,[x]:new Map,[de]:0,[S]:new Map,[M]:new Set,[V]:new Map,[G]:new Set,[U]:new Set,[K]:new Map,[L]:new Map,[z]:!1,[te]:Q()}),t}function Ht(e){j.push(e),Pe.forEach(t=>$e(e,t))}function No(...e){let t=Ft(...e);return Ht(t),t}var Uo=(e,t=Xe())=>(e[P]=t,e[A]&&e[A].forEach(o=>et(e,o)),e[$]=[t===-1?new Array:new Array(t)],e[W]=new Map,e[Ae]=[],e[E]=Q(),e[A]=e[E].dense,e[Y]=1,e[x]=new Map,e[de]=0,e[S]=new Map,e[M]=new Set,e[V]=new Map,e[G]=new Set,e[U]=new Set,e[K]=new Map,e[L]=new Map,e[z]=!1,e[k]=!1,e),qo=e=>{let t=e;delete t[P],delete t[$],delete t[W],delete t[Ae],delete t[E],delete t[A],delete t[Y],delete t[x],delete t[de],delete t[S],delete t[M],delete t[V],delete t[G],delete t[U],delete t[K],delete t[L],delete t[te],delete t[z],delete t[k];let o=j.indexOf(e);o!==-1&&j.splice(o,1)},Yo=e=>Array.from(e[x].keys()),Lo=e=>e[E].dense.slice(0),Ut=e=>{let t=e[P];e[Y]*=2,e[Y]>=2**31&&(e[Y]=1,e[$].push(t===-1?new Array:new Array(t)))},Ot=(e,t)=>e[E].has(t),Fo=e=>(e[z]=!0,e),Ho=e=>(e[k]=!0,e);var Go=e=>(t,...o)=>(e(t,...o),t);function Vo(e){let t=typeof e=="function"?e:ve(e),o=-1,r=s=>{let u=s[S].get(t);u&&(o=u.enterQueues.push(Q())-1)};for(let s of j)r(s);let n=(s,u=!0)=>{let i=s[S].get(t);if(i.enterQueues[o].dense.length===0)return Se;{let a=i.enterQueues[o].dense.slice();return u&&i.enterQueues[o].reset(),a}};return t[ne].push(r),n}function Jo(e){let t=typeof e=="function"?e:ve(e),o=-1,r=s=>{let u=s[S].get(t);u&&(o=u.exitQueues.push(Q())-1)};for(let s of j)r(s);let n=(s,u=!0)=>{let i=s[S].get(t);if(o===-1&&(o=i.exitQueues.push(Q())-1),i.exitQueues[o].dense.length===0)return Se;{let a=i.exitQueues[o].dense.slice();return u&&i.exitQueues[o].reset(),a}};return t[ne].push(r),n}var tt={REPLACE:0,APPEND:1,MAP:2},ot=!1;var Gt=(e,t)=>e.concat(t),Kt=e=>t=>!e(t),Rt=e=>e[O],Mt=Rt,Vt=Kt(Mt),wt=e=>typeof e=="function"&&e[N],Jt=Kt(wt),Xt=e=>wt(e)&&e()[1]==="changed",eo=e=>Object.getOwnPropertySymbols(e).includes(x),Zt=e=>e()[0],rt=e=>{if(eo(e))return[[],new Map];let t=e.filter(Jt).filter(Mt).map(Rt).reduce(Gt,[]),o=e.filter(Xt).map(Zt).filter(Mt).map(Rt).reduce(Gt,[]),r=e.filter(Jt).filter(Vt),n=e.filter(Xt).map(Zt).filter(Vt),s=[...t,...r,...o,...n],u=[...o,...n].reduce((i,a)=>{let f=Symbol();return Fe(a,f),i.set(a,f),i},new Map);return[s,u]},Xo=(e,t=2e7)=>{let o=eo(e),[r,n]=rt(e),s=new ArrayBuffer(t),u=new DataView(s),i=new Map;return f=>{ot&&([r,n]=rt(e),ot=!1),o&&(r=[],e[x].forEach((_,d)=>{d[O]?r.push(...d[O]):r.push(d)}));let m;Object.getOwnPropertySymbols(f).includes(x)?(m=f,f=f[A]):m=Dt.get(f[0]);let p=0;if(!f.length)return s.slice(0,p);let R=new Map;for(let _=0;_<r.length;_++){let d=r[_],g=d[X](),me=n.get(d),y=me?d[me]:null;R.has(g)||R.set(g,new Map),u.setUint8(p,_),p+=1;let le=p;p+=4;let b=0;for(let T=0;T<f.length;T++){let l=f[T],c=i.get(l);c||(c=i.set(l,new Set).get(l)),c.add(l);let h=y&&R.get(g).get(l)||!c.has(g)&&F(m,g,l);if(R.get(g).set(l,h),h)c.add(g);else if(!F(m,g,l)){c.delete(g);continue}let I=p;if(u.setUint32(p,l),p+=4,d[se]){b++;continue}if(ArrayBuffer.isView(d[l])){let oe=d[l].constructor.name.replace("Array",""),Ue=d[l][ie],At=d[l][ae],to=p;p+=At;let nt=0;for(let re=0;re<d[l].length;re++){if(y){let ro=y[l][re]!==d[l][re];if(y[l][re]=d[l][re],!ro&&!h)continue}u[`set${Ue}`](p,re),p+=At;let oo=d[l][re];u[`set${oe}`](p,oo),p+=d[l].BYTES_PER_ELEMENT,nt++}if(nt>0)u[`set${Ue}`](to,nt),b++;else{p=I;continue}}else{if(y){let Ue=y[l]!==d[l];if(y[l]=d[l],!Ue&&!h){p=I;continue}}let oe=d.constructor.name.replace("Array","");u[`set${oe}`](p,d[l]),p+=d.BYTES_PER_ELEMENT,b++}}b>0?u.setUint32(le,b):p-=5}return s.slice(0,p)}},v=new Map,Zo=e=>{let t=Object.getOwnPropertySymbols(e).includes(x),[o]=rt(e),r=new Set;return(s,u,i=0)=>{v.clear(),ot&&([o]=rt(e),ot=!1),t&&(o=[],e[x].forEach((_,d)=>{d[O]?o.push(...d[O]):o.push(d)}));let a=s[K],f=s[L],m=new DataView(u),p=0;for(;p<u.byteLength;){let _=m.getUint8(p);p+=1;let d=m.getUint32(p);p+=4;let g=o[_];for(let me=0;me<d;me++){let y=m.getUint32(p);if(p+=4,i===tt.MAP)if(a.has(y))y=a.get(y);else if(v.has(y))y=v.get(y);else{let b=pe(s);a.set(y,b),f.set(b,y),v.set(y,b),y=b}if(i===tt.APPEND||i===tt.REPLACE&&!s[E].has(y)){let b=v.get(y)||pe(s);v.set(y,b),y=b}let le=g[X]();if(F(s,le,y)||H(s,le,y),r.add(y),!le[se])if(ArrayBuffer.isView(g[y])){let b=g[y],T=m[`get${b[ie]}`](p);p+=b[ae];for(let l=0;l<T;l++){let c=m[`get${b[ie]}`](p);p+=b[ae];let h=m[`get${b.constructor.name.replace("Array","")}`](p);if(p+=b.BYTES_PER_ELEMENT,g[xe]){let I;if(a.has(h))I=a.get(h);else if(v.has(h))I=v.get(h);else{let oe=pe(s);a.set(h,oe),f.set(oe,h),v.set(h,oe),I=oe}g[y][c]=I}else g[y][c]=h}}else{let b=m[`get${g.constructor.name.replace("Array","")}`](p);if(p+=g.BYTES_PER_ELEMENT,g[xe]){let T;if(a.has(b))T=a.get(b);else if(v.has(b))T=v.get(b);else{let l=pe(s);a.set(b,l),f.set(l,b),v.set(b,l),T=l}g[y]=T}else g[y]=b}}}let R=Array.from(r);return r.clear(),R}};var Ko=(...e)=>t=>{let o=t;for(let r=0;r<e.length;r++){let n=e[r];o=n(o)}return o};var Bn=(e=[])=>{let t={};return Ge(t,{[qe]:e,[B]:new Map}),t},Et=(e,t)=>{if(t[B].has(e))return t[B].get(e);let o=wo(e);return $t(e,t[qe],o),t[B].set(e,o),o},zn=(e,t)=>t.map(o=>Et(e,o)),wo=e=>{let t=pe(e);return H(e,ge,t),t};var jn={...xt,...ut,...it,...at,...bt,...St,...ct};export{Eo as Changed,tt as DESERIALIZE_MODE,_e as IsA,So as Not,ce as Pair,jn as SYMBOLS,he as Types,D as Wildcard,H as addComponent,$t as addComponents,pe as addEntity,wo as addPrefab,Me as archetypeHash,kt as commitRemovals,No as createWorld,Tt as defineComponent,Zo as defineDeserializer,Vo as defineEnterQueue,Jo as defineExitQueue,Bn as definePrefab,ve as defineQuery,It as defineRelation,Xo as defineSerializer,Go as defineSystem,Ft as defineWorld,qo as deleteWorld,Ho as enableBufferedQueries,Fo as enableManualEntityRecycling,Ao as enterQuery,Ct as entityExists,Po as exitQuery,Io as flushRemovedEntities,Lo as getAllEntities,ko as getDefaultSize,Ne as getEntityComponents,Ie as getRelationTargets,Yo as getWorldComponents,F as hasComponent,xo as parentArray,Ko as pipe,Be as query,q as registerComponent,vo as registerComponents,Et as registerPrefab,zn as registerPrefabs,$e as registerQuery,Ht as registerWorld,fe as removeComponent,Bo as removeComponents,et as removeEntity,Mo as removeQuery,Ro as resetChangedQuery,Lt as resetGlobals,Uo as resetWorld,jo as setDefaultSize,_o as setRemovedRecycleThreshold,j as worlds};
